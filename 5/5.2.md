## プロセス管理
タスク：CPUから見た処理単位

タスクが待ち行列に入って、実行可能状態で自分の番が来るのを待つ　→　CPUが割り当てられる（自分の番が回ってくる）と、実行状態に　→　割り当てられた時間分実行されるか、より優先度の高いタスクが割り込んでくるかして、待機状態に戻る（また順番が来るまで待つ）。あるいは完了して、タスク完了（消える）

タスクはカーネルが管理し、優先順位やらレジスタ上のアドレスとかとともに管理される。  
積んであるタスクを効率的に処理するために、それぞれを少しずつ順番に実行していくが、この時の切り替えをコンテキストスイッチという。メモリ空間の切り替えはデータの読出しとかあるので、比較的時間がかかる。


### 5.2.2 タスクのスケジューリング
 - イベントドリブン：マウスクリックなどのイベントが発生したときに切り替わる
 - タイムスライス：一定時間ごとに切り替わる
 - 到着順方式：できるやつから先にやる
 - 静的優先順位方式：先に誘電度をタスクに割り当てて、その順で処理。優先順位が低いやつが残りがち。
 - 動的優先順位方式：あまり待たされると優先順位が上がって処理される感じ
 - ラウンドロビン
 - フィードバック待ち行列方式：何回順番が回ってきてもなかなか終わらない奴はとりあえず後回し（優先度を下げる）


プリエンプション：タスクの割り込みにより、実行中のものを中断  


### 5.2.3 同期制御
他のタスクと合図を送りあって、それを合図にタスクを処理する。  
タスクが合図を出し合う手段として、以下のようなものがある
 - メモリ上の同じ空間をもちいてやりとり
 - OSがメールみたいな形でキューをおくるとか
 - 一方のタスクの出力を他方におくるとか

メモリ共有はメモリに制限ができるが、ほかのだとメッセージを管理する仕組みが必要になったりするので、どれが一番いいという感じでもなさそう。


### 5.2.4 排他制御
一つのデータを同じタイミングで処理し始めて整合がとれなくなる（クリティカルセクション）と困る。なので、一方が握ってるときは他方が待つ。  
同じCPUで実行されていない場合、割り込み禁止ができないので、共有メモリに、「今このデータ握ってるから、これを使いたい人は待ってね！」を書いておく。

二値セマフォ：使ってる = 1, 使ってない = 0 みたいな形で、他のタスクがクリティカルセクションに入らないようにする。  
ゼネラルセマフォ：複数のタスクを協調して実行するために、1,0ではなく、残りN人、みたいな形で情報をもつ  


### 5.2.5 デッドロック
お互いが相手が終わるのを待って、どちらも動けなくなるやつ。

対策
 - デッドロックが起こったら一つを強制的に解除して解消する
 - 先に順番を決めておく
 - 状況に応じて順番を決める


### 5.2.6 プロセスとスレッド
 - プロセス：タスクと同じ認識。プログラムの処理単位みたいな。
   - プロセス間で資源共有できない
   - 子プロセスやスレッドを作れる
 - スレッド：プロセスから作られる並列処理の単位。
   - プロセスから生えてくる
   - スレッド間は資源の共有ができるので、一つのプロセスに複数のスレッドを生やして（マルチスレッド）処理できると効率いい。